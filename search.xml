<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CS]]></title>
    <url>%2F2018%2F07%2F27%2FCS%2F</url>
    <content type="text"><![CDATA[$y=Ax$，$y\in R^m$是观测到的信号，$x\in R^n$为原始信号，$A\in R^{m\times n}$。$m\lt n$时，这个方程或者无解，或者有无穷多解。如何从这无穷多个解中找到x？我们可以利用x的其他性质，对这个方程添加约束。假设x是一个稀疏向量，一个明智的目标就是找到最稀疏的向量x，使其满足$y=Ax $，即：$$ min||x||_0 \text{ s.t. } y=Ax $$ $l^0$范数为向量中非零项的个数，它并不是一个范数范数需要满足三条性质： $||\alpha x = |\alpha|||x||$ $||x||\ge0 $, $ ||x||=0 $ \text{ iif } $ x=0$ $||x+y||\le||x||+||y||$$l^0$范数不满足性质1 这是一个组合优化问题，属于NP hard问题，通过暴力方式求解。12345678910111213141516171819202122232425262728293031323334import numpy as npfrom itertools import permutationsdef resconstruction(A,y): _,n = A.shape res = np.zeros((n,1)) for i in range(1,n): for idx in permutations(range(n),i): A_idx = A[:,idx] z,_,_,_ = np.linalg.lstsq(A_idx,y) if np.allclose(A_idx*z,y): t=0 for j in idx: res[j]=z[t] t+=1 return res return resif __name__ == '__main__': m = 5#方程组个数 n = 12#未知数个数 k = 4#未知数中非零项个数 np.random.seed(0) #随机生成矩阵A A = np.zeros((m,n)) for i in range(n): A[:,i] = np.random.rand(m) A = np.matrix(A) #随机生成稀疏向量x x = np.zeros((n,1)) x[:k] = np.random.rand(k,1) np.random.shuffle(x) y = A*x res = resconstruction(A,y) print('x: ',x) print('results: ',res) 通过上述代码我们可以发现，k小于等于4时，我们总能够恢复出x，而k大于4时，无法恢复x。可以证明，在A的null space不包含稀疏向量的时候，$l^0$最小化可以恢复足够稀疏的向量x。这一性质当且仅当A的任意2k列都是线性无关的时候成立，即$$||x||_0\le \frac{1}{2}krank(A)$$。but如何验证2k列线性无关,或者说如何计算krank？同样是NP hard。考虑到$l^0$范数不好优化，我们希望将其放松到一个具有稀疏性质的凸函数。显然可以将$l_0$优化问题放松到$l^1$优化问题。可以使用Jensen不等式证明：如果我们找到任意一个凸函数f在集合$B_\infty = \lbrace x| ||x||_\infty \le 1 \rbrace $满足$f\le ||·||_0$，那么$f\le ||·||_1$ 凸函数定义$$f(\alpha x+(1-\alpha )x’)\le \alpha f(x)+(1-\alpha)f(x’)$$ Jensen inequality$$f(\sum_{i=1}^{k} \lambda_i x_i)\le \sum_{i=1}^{k} \lambda_if(x_i)$$ 求解$l^1$优化问题有两个难点 含有一个约束项 函数不可导 针对这两个问题可以使用投影梯度下降代替梯度下降,采用次梯度代替梯度。 梯度下降$$x_{k+1} = x_k-\nabla f(x_k)$$ 将点z投影到平面C即在平面中找到距离z最近的点x: $P_C[z] = \mathop{\arg\min}_{x\in C}{\frac{1}{2}||z-x||_2^2}$对于封闭的凸集有毕解$$P_C[z] = z-A^T(AA^T)^{-1}(Az-y)$$ 投影梯度下降$$x_{k+1} = P_C[x_k-t_k\nabla f(x_k)]$$ 12345678910111213141516171819202122232425262728import numpy as npdef recovery(A,y): F = np.linalg.pinv(A) x_ = F*y F = F*A F = np.eye(F.shape[0])-F x=np.zeros_like(x_) for t in range(1,1000000): x = x_+F*(x-1/t*np.sign(x)) return xif __name__ == '__main__': m = 5#方程组个数 n = 12#未知数个数 k = 5#未知数中非零项个数 np.random.seed(0) #随机生成矩阵A A = np.zeros((m,n)) for i in range(n): A[:,i] = np.random.rand(m) A = np.matrix(A) #随机生成稀疏向量x x = np.zeros((n,1)) x[:k] = np.random.rand(k,1) np.random.shuffle(x) y = A*x res = recovery(A,y) print('x: ',x) print('results: ',res)]]></content>
      <tags>
        <tag>压缩感知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
